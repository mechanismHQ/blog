"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[286],{4666:function(e,n,t){t.r(n),t.d(n,{assets:function(){return c},contentTitle:function(){return l},default:function(){return f},frontMatter:function(){return s},metadata:function(){return u},toc:function(){return d}});var a=t(7462),i=t(3366),o=(t(7294),t(3905)),r=["components"],s={title:"New Clarity functions coming in Stacks 2.1",sidebar_label:"Clarity 2.1 functions",slug:"clarity-2-functions",tags:["Clarity"]},l=void 0,u={permalink:"/clarity-2-functions",source:"@site/blog/2022-03-07-clarity-2-1-functions.md",title:"New Clarity functions coming in Stacks 2.1",description:"With the Stacks blockchain's 2.1 upgrade approaching, there is a lot to look forward to. As a Clarity developer, I'm excited about a bunch of new built-in Clarity functions that will be included.",date:"2022-03-07T00:00:00.000Z",formattedDate:"March 7, 2022",tags:[{label:"Clarity",permalink:"/tags/clarity"}],truncated:!0,authors:[],frontMatter:{title:"New Clarity functions coming in Stacks 2.1",sidebar_label:"Clarity 2.1 functions",slug:"clarity-2-functions",tags:["Clarity"]}},c={authorsImageUrls:[]},d=[{value:"<code>tx-sponsor?</code>",id:"tx-sponsor",level:3},{value:"<code>is-in-mainnet</code>",id:"is-in-mainnet",level:3},{value:"Converting buffers to integers",id:"converting-buffers-to-integers",level:3},{value:"Converting strings to integers (and back)",id:"converting-strings-to-integers-and-back",level:3},{value:"Slice",id:"slice",level:3},{value:"Comparators for strings and buffs",id:"comparators-for-strings-and-buffs",level:3},{value:"STX account information",id:"stx-account-information",level:3},{value:"STX transfer with memo",id:"stx-transfer-with-memo",level:3},{value:"<code>is-standard</code>",id:"is-standard",level:3},{value:"<code>principal-of</code>",id:"principal-of",level:3}],p={toc:d};function f(e){var n=e.components,t=(0,i.Z)(e,r);return(0,o.kt)("wrapper",(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"With the Stacks blockchain's 2.1 upgrade approaching, there is a lot to look forward to. As a Clarity developer, I'm excited about a bunch of new built-in Clarity functions that will be included."),(0,o.kt)("p",null,"Eager developers can learn about these new functions by digging in to issues and pull requests in the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/stacks-network/stacks-blockchain"},"stacks-blockchain")," repository. Because many developers haven't seen these yet, I wanted to highlight them all in a single place."),(0,o.kt)("p",null,"To see the raw source and documentation for Clarity functions coming in 2.1, ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/stacks-network/stacks-blockchain/commits/next/src/vm/docs/mod.rs"},"check out the docs file in the ",(0,o.kt)("inlineCode",{parentName:"a"},"next")," branch"),"."),(0,o.kt)("h3",{id:"tx-sponsor"},(0,o.kt)("inlineCode",{parentName:"h3"},"tx-sponsor?")),(0,o.kt)("p",null,'Stacks supports "sponsored transactions". These are transactions that are signed by a user, as usual, except that the transaction fee is covered by a "sponsor". This can support excellent user experiences, where users don\'t even need to own STX to make a transaction.'),(0,o.kt)("p",null,"With ",(0,o.kt)("inlineCode",{parentName:"p"},"tx-sponsor?"),", you can have special logic depending on the sponsor. For example, you could have a contract that reimburses STX fees to the sponsor in another asset."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-clarity"},"(define-public (pay-sponsor)\n  (match tx-sponsor?\n    sponsor (begin\n      ;; do something if this tx is sponsored\n      (try! (ft-transfer? my-token u100 tx-sender sponsor))\n      (ok true)\n    )\n    (ok false)\n  )\n)\n")),(0,o.kt)("h3",{id:"is-in-mainnet"},(0,o.kt)("inlineCode",{parentName:"h3"},"is-in-mainnet")),(0,o.kt)("p",null,"This one's pretty straightforward - it's a constant variable that returns ",(0,o.kt)("inlineCode",{parentName:"p"},"true")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"false")," based on whether this environment is mainnet. Current contracts will need to have hard-coded flags that need to be changed before being deployed to different environments."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-clarity"},";; print a message if on testnet\n(define-private (testnet-debug (message (string-ascii 32)))\n  (if is-in-mainnet message (print message))\n)\n")),(0,o.kt)("h3",{id:"converting-buffers-to-integers"},"Converting buffers to integers"),(0,o.kt)("p",null,"We have a bunch of similar functions for converting buffers to integers. You can create signed or unsigned integers, and can convert from big-endian or little-endian encoding."),(0,o.kt)("p",null,"The available functions are:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"buff-to-int-le")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"buff-to-uint-le")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"buff-to-int-be")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"buff-to-uint-be"))),(0,o.kt)("p",null,"One really useful mechanism for this is to convert random hashes into a number, and use that as a random number in your contract. You could, for example, take the ",(0,o.kt)("inlineCode",{parentName:"p"},"vrf-seed")," and convert it into a number, and have random probabilities based on that number."),(0,o.kt)("p",null,'Given a hash, here\'s how you can build a "coin flip" function. ',(0,o.kt)("strong",{parentName:"p"},"This function has not been thoroughly tested")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-clarity"},'(define-constant max-uint-buff 0xffffffffffffffffffffffffffffffff)\n(define-constant max-uint (buff-to-uint-be max-uint-buff))\n(define-constant half-uint (/ max-uint u2))\n\n;; given a "random" buffer, return true half of the time.\n(define-read-only (coin-flip (buffer (buff 16)))\n  (<= (buff-to-uint-be buffer) half-uint)\n)\n')),(0,o.kt)("p",null,"The buffer that you input to these functions can only be of length ",(0,o.kt)("inlineCode",{parentName:"p"},"16"),", so you'll have to ",(0,o.kt)("inlineCode",{parentName:"p"},"slice")," longer buffers (like ",(0,o.kt)("inlineCode",{parentName:"p"},"vrf-seed"),"). More on that below!"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-clarity"},";; turn the vrf-seed into a uint\n(define-read-only (vrf-to-uint)\n  (let\n    (\n      (vrf-full (unwrap! (get-block-info? vrf-seed block-height) (err u0)))\n      (vrf-slice (slice vrf-full u0 u16))\n      (vrf (unwrap! (as-max-len? vrf-slice u16) (err u1)))\n      (rand-uint (buff-to-uint-be vrf))\n    )\n    (ok rand-uint)\n  )\n)\n")),(0,o.kt)("h3",{id:"converting-strings-to-integers-and-back"},"Converting strings to integers (and back)"),(0,o.kt)("p",null,"Now there are native functions for converting strings to integers and integers to strings."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"int-to-ascii")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"int-to-utf8")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"string-to-uint")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"string-to-int"))),(0,o.kt)("p",null,"For integer conversion, the same function works with both ",(0,o.kt)("inlineCode",{parentName:"p"},"uint")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"int"),". Same for string conversion - you can use ",(0,o.kt)("inlineCode",{parentName:"p"},"string-ascii")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"string-utf8"),"."),(0,o.kt)("p",null,"When converting a string to an integer, the result is ",(0,o.kt)("inlineCode",{parentName:"p"},"(optional uint)"),". If you pass a number that can't be converted, the result is ",(0,o.kt)("inlineCode",{parentName:"p"},"none"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-clarity"},'(int-to-ascii u32) ;; "32"\n(string-to-uint "32");; (some u32)\n(string-to-uint "not-number") ;; none\n')),(0,o.kt)("p",null,"One example where this could be useful is when you need to add index numbers to strings in a list. Here's a function that does that:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-clarity"},'(define-read-only (indexed-list (items (list 10 (string-ascii 32))))\n  (let\n    (\n      (iterator { index: u1, names: (list) })\n      (fold-result (try! (fold indexed-list-fold items (ok iterator))))\n      (names (get names fold-result))\n    )\n    (ok names)\n  )\n)\n\n(define-read-only (indexed-list-fold\n    (item (string-ascii 32))\n    (iterator-resp (response { index: uint, names: (list 10 (string-ascii 35)) } uint))\n  )\n  (let\n    (\n      (iterator (try! iterator-resp))\n      (names (unwrap! (as-max-len? (get names iterator) u9) (err u0)))\n      (index (get index iterator))\n      (name-a (concat (int-to-ascii index) ". "))\n      (name-full (concat name-a item))\n      ;; because our list size is only 10, we know this string can\'t be more than\n      ;; 35 characters. By default, the string type would be (string-ascii 74), to\n      ;; account for the largest possible integer.\n      (name (unwrap! (as-max-len? name-full u35) (err u1)))\n      (new-names (append names name))\n    )\n    (ok { index: (+ index u1), names: new-names })\n  )\n)\n\n(try! (indexed-list (list "alice" "bob"))) ;; (list "1. alice" "2. bob")\n')),(0,o.kt)("h3",{id:"slice"},"Slice"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"slice")," is a very helpful utility when dealing with hashes, buffers, and strings. This function works like ",(0,o.kt)("inlineCode",{parentName:"p"},"slice")," in most languages - it selects the elements between ",(0,o.kt)("inlineCode",{parentName:"p"},"beginning")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"end")," indexes that you specify. This is a crucial utility when parsing a Bitcoin block header, for example."),(0,o.kt)("p",null,"Previously, you could only use ",(0,o.kt)("inlineCode",{parentName:"p"},"as-max-len?")," if you wanted to take two long strings and concatenate them into a shorter string. For example, imagine you have two tokens A and B. Their on-chain ",(0,o.kt)("inlineCode",{parentName:"p"},"name")," returns a 16-character string, but you want to create a pool whose name is auto-generated with their two names. If you tried that with ",(0,o.kt)("inlineCode",{parentName:"p"},"as-max-len?"),", you'd get a ",(0,o.kt)("inlineCode",{parentName:"p"},"none")," result if either of the names was too long. With ",(0,o.kt)("inlineCode",{parentName:"p"},"slice"),", you can cut off their names if they go too long."),(0,o.kt)("p",null,"This becomes extra handy when you're trying to conform to traits that limit the length of a result."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Note about slice"),": At the moment, I saw some unintuitive behavior around the length of the result of ",(0,o.kt)("inlineCode",{parentName:"p"},"slice"),". The length of the result of ",(0,o.kt)("inlineCode",{parentName:"p"},"slice")," did not actually shorten to what I was expecting. I had to use ",(0,o.kt)("inlineCode",{parentName:"p"},"as-max-len?")," to do type-safe operations. I'll keep this updated if there are any changes."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-clarity"},';; Take two strings and return "${a} ${b} Pool", with a length no longer than 32 characters.\n(define-read-only (make-pool-name (name-a (string-ascii 32)) (name-b (string-ascii 32)))\n  (let\n    (\n      (a-short (slice name-a u0 u13))\n      (b-short (slice name-b u0 u13))\n      (a (concat a-short " "))\n      (b (concat b-short " Pool"))\n    )\n    (concat a b)\n  )\n)\n')),(0,o.kt)("h3",{id:"comparators-for-strings-and-buffs"},"Comparators for strings and buffs"),(0,o.kt)("p",null,"Clarity already has ",(0,o.kt)("inlineCode",{parentName:"p"},">"),", ",(0,o.kt)("inlineCode",{parentName:"p"},">="),", ",(0,o.kt)("inlineCode",{parentName:"p"},"<"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"<=")," for integers. In 2.1, you can also use this with strings and buffers."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-clarity"},'(define-read-only (test-string-comparisons)\n  (begin\n    (asserts! (> "bbb" "aaa") (err u0))\n    (asserts! (>= u"bbb" u"bbb") (err u1))\n    (asserts! (< 0x01 0x02) (err u2))\n    (ok true)\n  )\n)\n')),(0,o.kt)("h3",{id:"stx-account-information"},"STX account information"),(0,o.kt)("p",null,"You can currently use ",(0,o.kt)("inlineCode",{parentName:"p"},"stx-get-balance"),", but in 2.1 you can get information about the locked balance (through Stacking) for a given principal. This function returns a tuple with ",(0,o.kt)("inlineCode",{parentName:"p"},"locked"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"unlock-height"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"unlocked"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-clarity"},"(stx-account 'ST000000000000000000002AMW42H)\n;; { locked: u0, unlock-height: u0, unlocked: u0 }\n")),(0,o.kt)("p",null,"Here is a simple function that returns ",(0,o.kt)("inlineCode",{parentName:"p"},"true")," if the user is currently stacking:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-clarity"},"(define-read-only (is-stacking (account principal))\n  (if (> (get locked (stx-account account)) u0)\n    true\n    false\n  )\n)\n")),(0,o.kt)("h3",{id:"stx-transfer-with-memo"},"STX transfer with memo"),(0,o.kt)("p",null,'Stacks is an account-based protocol, so exchanges typically rely on users having a unique "memo" to associate transfers into their exchange account. This works well for vanilla STX transfers (which support memos), but exchanges won\'t recognize STX transfers from within contract calls.'),(0,o.kt)("p",null,'In fact, exchanges ran into an issue when users tried to withdraw from one exchange to another. Instead of making dozens of individual transactions, exchanges would prefer to use a "bulk send" contract call. This works well, except that you can\'t natively include a memo. The ecosystem ended up developing a special ',(0,o.kt)("inlineCode",{parentName:"p"},"send-many-memo")," contract that would ",(0,o.kt)("inlineCode",{parentName:"p"},"print")," memos, and exchanges could use an API to recognize these transfers."),(0,o.kt)("p",null,"Using a special contract is messy, though. The new ",(0,o.kt)("inlineCode",{parentName:"p"},"stx-transfer-memo?")," function will simplify all this."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-clarity"},"(stx-transfer-memo? u1234 tx-sender 'ST000000000000000000002AMW42H 0x010203)\n")),(0,o.kt)("h3",{id:"is-standard"},(0,o.kt)("inlineCode",{parentName:"h3"},"is-standard")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"is-standard")," function simply checks to see if a given ",(0,o.kt)("inlineCode",{parentName:"p"},"principal")," is in the correct format for the current network. This allows for additional safety - if a user sends tokens to a principal that could never spend them (on this network), that would be a bad outcome."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-clarity"},"(is-standard 'STB44HYPYAT2BB2QE513NSP81HTMYWBJP02HPGK6) ;; returns true on testnet and false on mainnet\n(is-standard 'STB44HYPYAT2BB2QE513NSP81HTMYWBJP02HPGK6.foo) ;; returns true on testnet and false on mainnet\n(is-standard 'SP3X6QWWETNBZWGBK6DRGTR1KX50S74D3433WDGJY) ;; returns true on mainnet and false on testnet\n(is-standard 'SP3X6QWWETNBZWGBK6DRGTR1KX50S74D3433WDGJY.foo) ;; returns true on mainnet and false on testnet\n(is-standard 'SZ2J6ZY48GV1EZ5V2V5RB9MP66SW86PYKKQ9H6DPR) ;; returns false on both mainnet and testnet\n")),(0,o.kt)("h3",{id:"principal-of"},(0,o.kt)("inlineCode",{parentName:"h3"},"principal-of")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"principal-of")," converts a public key to a standard STX address. This was already built in Stacks 2.0, but it shipped with a bug on mainnet. On mainnet, the result would return a testnet-formatted address. Unfortunately, that made this function mostly useless. The fix had to wait until 2.1 because fixing it would technically be consensus-breaking, so it needed to be in a hard fork."),(0,o.kt)("p",null,"I've found that there are a ton of interesting use cases for ",(0,o.kt)("inlineCode",{parentName:"p"},"principal-of"),". It allows for all sorts of off-chain signatures to execute address-specific logic in a contract."),(0,o.kt)("p",null,"For example, imagine a voting contract. The contract keeps track of what individual users vote on. This could get expensive with lots of voters. Instead, signatures could be generated offline and then submitted on-chain in a single batch transaction."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-clarity"},"(define-map votes-map principal uint)\n\n;; submit a list of votes, with signatures generated off-chain\n(define-public (batch-votes (votes (list 20 { signature: (buff 65), proposal: uint })))\n  (ok (map process-vote votes))\n)\n\n(define-public (process-vote (vote { signature: (buff 65), proposal: uint }))\n  (let\n    (\n      (proposal (get proposal vote))\n      (message-hash (sha256 proposal))\n      (public-key (unwrap! (secp256k1-recover? message-hash (get signature vote)) (err u0)))\n      (voter (unwrap! (principal-of? public-key) (err u1)))\n    )\n    (map-set votes-map voter proposal)\n    (ok true)\n  )\n)\n")))}f.isMDXComponent=!0}}]);