"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[450],{6029:function(e){e.exports=JSON.parse('{"blogPosts":[{"id":"poxl-proportional-mining-rewards","metadata":{"permalink":"/poxl-proportional-mining-rewards","source":"@site/blog/2022-03-14-citycoins-1/index.md","title":"PoXL ideas: Proportional mining rewards","description":"In this post, I\u2019d like to make the case for changing how mining rewards in CityCoins (or any PoXL project) are distributed. Currently, mining is a \u201cwinner takes all\u201d model. Instead, I\u2019m advocating for proportional mining rewards.","date":"2022-03-15T00:00:00.000Z","formattedDate":"March 15, 2022","tags":[{"label":"CityCoins","permalink":"/tags/city-coins"},{"label":"PoXL","permalink":"/tags/po-xl"},{"label":"Tokenomics","permalink":"/tags/tokenomics"}],"truncated":true,"authors":[{"name":"Hank Stoever","twitter":"@heynky","imageURL":"https://github.com/hstove.png","key":"hank"}],"frontMatter":{"tags":["CityCoins","PoXL","Tokenomics"],"sidebar_label":"PoXL ideas (Part 1)","authors":["hank"],"hide_table_of_contents":false,"slug":"poxl-proportional-mining-rewards","date":"2022-03-15T00:00:00.000Z"},"nextItem":{"title":"New Clarity functions coming in Stacks 2.1","permalink":"/clarity-2-functions"}},"content":"In this post, I\u2019d like to make the case for changing how mining rewards in CityCoins (or any PoXL project) are distributed. Currently, mining is a \u201cwinner takes all\u201d model. Instead, I\u2019m advocating for **proportional mining rewards**.\\n\\n\x3c!--truncate--\x3e\\n\\nThe core thesis behind this change is:\\n\\n- Proportional rewards will increase miner participation\\n- Increasing miner participation is good for a PoXL project\\n\\n## PoXL vs PoX\\n\\nCityCoin\u2019s mining mechanism, Proof-of-Transfer-Lite (PoXL), is an almost direct port of the Stacks Proof-of-Transfer (PoX) mining mechanism. This has many benefits, but PoX is designed around certain goals that CityCoins do not have. The \u201cwinner takes all\u201d mining reward is one such example that is needed in PoX, but isn\u2019t required in PoXL.\\n\\nStacks mining requires a \\"leader election\\" consensus mechanism. The winning miner is responsible for forming an anchor blocks, as well as for proposing a microblock stream in between anchor blocks. CityCoins does not have any requirements for leader election, so there isn\u2019t a need to have a \u201cwinning miner\u201d.\\n\\n## The difficulty of profitable mining\\n\\nWhen CityCoins miners participate in mining, many are likely doing so in order to accumulate a project\'s tokens at a better price than they could receive on the open market.\\n\\nOne simple way to calculate mining profitability is to think of it in expected value (EV) terms. If I commit some amount of STX to mine a block, what is the expected value?\\n\\nPoXL mining is designed such that your probability of winning a block is equal to the proportion of funds you\'ve committed to that block.\\n\\nAs an example:\\n\\n- There are 900 STX committed from miners already\\n- The block reward is worth 2000 STX. In CityCoins projects, the block reward is not in STX, but it can be valued in STX.\\n- Alice commits 100 STX, bringing the total miner commit to 1000 STX\\n\\nIn this example, Alice has a 10% chance of winning the block (because she committed 100 out of 1000 STX). The expected value for Alice is then:\\n\\n```\\n0.1 * 2000 + 0.9 * 0 = 200 STX\\n```\\n\\nAccording to the EV calculation, Alice\'s expected value is 200 STX - double what she put in! Most of the time, you want to make an EV bet that 2x\'s your bid.\\n\\nIn reality, Alice will lose 100 STX and get nothing in return 9 times out of 10. In order to have a higher confidence that she\'ll make money from mining, Alice will need to mine many blocks. So, how many times would Alice need to mine to have a high probability of being +EV?\\n\\n### Cumulative binomial distributions\\n\\nPoXL mining is [binomial](https://en.wikipedia.org/wiki/Binomial_distribution) - you either win the block or you lose it. Using statistics, we can evaluate this as a [cumulative distribution function](https://en.wikipedia.org/wiki/Cumulative_distribution_function) to calculate how often a miner will end up profitable if they mine for a certain number of blocks. Now that the fancy words are out of the way, we\'ll explain what this means.\\n\\nWe\'ve created a [Google sheet](https://docs.google.com/spreadsheets/d/15ipYxuiMKBAUtat-ojwIS6xM1RoGda6lkpYRpq6QV2g/edit?usp=sharing) that does this math for you. It\'s pre-populated with a few real-world variables from recently mined MIA blocks.\\n\\nIn our calculator, we assume that a miner has a specific amount of STX that they want to spend to mine CityCoins. With that condition, we can evaluate how likely the miner is profitable if they commit _x_ amount of STX to mining each block.\\n\\nThe more STX a miner commits, the higher their chance of winning the block. However, when they spend more STX, they\'re not able to mine for as many blocks. Additionally, the more STX committed each block, the higher the _total_ miner commitment is, meaning that miner profitability is lower.\\n\\nWith these factors in mind, we can determine that **the best strategy for PoXL mining is to mine for many block with as few STX per block as possible.** The only downside to this strategy is that it will take a while to mine, meaning you\'ll have less time receiving Stacking rewards, and you\'ll have to spend more on transaction fees.\\n\\n![Profitability probability vs. spend](./%2BProfit%20probability%20vs.%20STX%20spent.png)\\n\\nAs we can see, there quickly becomes a point where your probability of ending of with profit from mining becomes less than 50%.\\n\\nWe can also demonstrate the need to mine for many blocks in order to end up profitable. To visualize this, we can set up a scenario with fixed variables and see how likely it is for a miner to be profitable based on the number of blocks they mined.\\n\\nIn this chart, the miner has a 5% chance of winning, and the miner discount is 11%. Because of this discount, the expected value of mining is +11%. However, actually making a profit depends on the number of blocks they mine.\\n\\n![profit vs blocks mined](./%2BProfit%20probability%20vs.%20Blocks%20mined.png)\\n\\nAs you can see, you need to mine for thousands of blocks in order to be confident that you\u2019ll make any profit at all, even with a high discount.\\n\\nAll of this is to show that **profitably mining in PoXL is hard and unlikely**.\\n\\n## Proportionally distributed mining rewards\\n\\nNow that we\'ve outlined the challenges behind \\"winner takes all\\" mining, we can look at an alternative - sharing mining rewards proportionally amongst all miners.\\n\\nIn this model, a miner who commits 10% of the total mining commitment would receive 10% of the total mining rewards for that block.\\n\\nThe best aspect of this alternative is that **it makes profitable mining much easier**. Remember our previous example? The expected value of Alice\'s mining action was a 2x return, but in reality she\'d lose her whole commitment 90% of the time. In this model, Alice will make her 2x return every single time.\\n\\nBy making profitable mining much more likely, our hypothesis is that this will lead to greater involvement in mining. Rational miners will commit to mining as much as possible, up until the point where the total miner commitment is equal to the block reward. In reality, there will likely still be some \\"miner discount\\" to account for transaction fees and price variability risk. However, we believe that the net discount will end up being lower in this scheme.\\n\\nTo support the argument that miners are more likely to continue mining as the miner discount gets smaller, we can evaluate a miner\'s chance of being profitable under these conditions.\\n\\nIn the following chart, we evaluate a scenario where a miner is going to mine 10 STX for 500 blocks. Using the same math as before, we can look at the chance that a miner is profitable as the discount approaches zero.\\n\\n![Profit vs discount](./%2BProfit%20probability%20vs.%20Discount.png)\\n\\nAs you can see, once the discount is below 10%, this miner can expect to lose money more than 50% of the time. A rational miner should either not mine, or they should commit to mining for many more blocks.\\n\\nCompare this to proportional mining rewards - **this miner will always be profitable as long as the discount is below zero!**\\n\\n---\\n\\nWe hope that this post sheds light on a mechanism change to PoXL and CityCoins that aims to increase miner participation. When more STX are committed to mining, that leads to more Stacking rewards and more funds raised for a City. Ultimately, we hope that these kinds of incremental improvements can help CityCoins and other DAOs to achieve overall success."},{"id":"clarity-2-functions","metadata":{"permalink":"/clarity-2-functions","source":"@site/blog/2022-03-07-clarity-2-1-functions.md","title":"New Clarity functions coming in Stacks 2.1","description":"With the Stacks blockchain\'s 2.1 upgrade approaching, there is a lot to look forward to. As a Clarity developer, I\'m excited about a bunch of new built-in Clarity functions that will be included.","date":"2022-03-07T00:00:00.000Z","formattedDate":"March 7, 2022","tags":[{"label":"Clarity","permalink":"/tags/clarity"}],"truncated":true,"authors":[],"frontMatter":{"title":"New Clarity functions coming in Stacks 2.1","sidebar_label":"Clarity 2.1 functions","slug":"clarity-2-functions","tags":["Clarity"]},"prevItem":{"title":"PoXL ideas: Proportional mining rewards","permalink":"/poxl-proportional-mining-rewards"}},"content":"With the Stacks blockchain\'s 2.1 upgrade approaching, there is a lot to look forward to. As a Clarity developer, I\'m excited about a bunch of new built-in Clarity functions that will be included.\\n\\nEager developers can learn about these new functions by digging in to issues and pull requests in the [stacks-blockchain](https://github.com/stacks-network/stacks-blockchain) repository. Because many developers haven\'t seen these yet, I wanted to highlight them all in a single place.\\n\\n\x3c!--truncate--\x3e\\n\\nTo see the raw source and documentation for Clarity functions coming in 2.1, [check out the docs file in the `next` branch](https://github.com/stacks-network/stacks-blockchain/commits/next/src/vm/docs/mod.rs).\\n\\n### `tx-sponsor?`\\n\\nStacks supports \\"sponsored transactions\\". These are transactions that are signed by a user, as usual, except that the transaction fee is covered by a \\"sponsor\\". This can support excellent user experiences, where users don\'t even need to own STX to make a transaction.\\n\\nWith `tx-sponsor?`, you can have special logic depending on the sponsor. For example, you could have a contract that reimburses STX fees to the sponsor in another asset.\\n\\n```clarity\\n(define-public (pay-sponsor)\\n  (match tx-sponsor?\\n    sponsor (begin\\n      ;; do something if this tx is sponsored\\n      (try! (ft-transfer? my-token u100 tx-sender sponsor))\\n      (ok true)\\n    )\\n    (ok false)\\n  )\\n)\\n```\\n\\n### `is-in-mainnet`\\n\\nThis one\'s pretty straightforward - it\'s a constant variable that returns `true` or `false` based on whether this environment is mainnet. Current contracts will need to have hard-coded flags that need to be changed before being deployed to different environments.\\n\\n```clarity\\n;; print a message if on testnet\\n(define-private (testnet-debug (message (string-ascii 32)))\\n  (if is-in-mainnet message (print message))\\n)\\n```\\n\\n### Converting buffers to integers\\n\\nWe have a bunch of similar functions for converting buffers to integers. You can create signed or unsigned integers, and can convert from big-endian or little-endian encoding.\\n\\nThe available functions are:\\n\\n- `buff-to-int-le`\\n- `buff-to-uint-le`\\n- `buff-to-int-be`\\n- `buff-to-uint-be`\\n\\nOne really useful mechanism for this is to convert random hashes into a number, and use that as a random number in your contract. You could, for example, take the `vrf-seed` and convert it into a number, and have random probabilities based on that number.\\n\\nGiven a hash, here\'s how you can build a \\"coin flip\\" function. **This function has not been thoroughly tested**\\n\\n```clarity\\n(define-constant max-uint-buff 0xffffffffffffffffffffffffffffffff)\\n(define-constant max-uint (buff-to-uint-be max-uint-buff))\\n(define-constant half-uint (/ max-uint u2))\\n\\n;; given a \\"random\\" buffer, return true half of the time.\\n(define-read-only (coin-flip (buffer (buff 16)))\\n  (<= (buff-to-uint-be buffer) half-uint)\\n)\\n```\\n\\nThe buffer that you input to these functions can only be of length `16`, so you\'ll have to `slice` longer buffers (like `vrf-seed`). More on that below!\\n\\n```clarity\\n;; turn the vrf-seed into a uint\\n(define-read-only (vrf-to-uint)\\n  (let\\n    (\\n      (vrf-full (unwrap! (get-block-info? vrf-seed block-height) (err u0)))\\n      (vrf-slice (slice vrf-full u0 u16))\\n      (vrf (unwrap! (as-max-len? vrf-slice u16) (err u1)))\\n      (rand-uint (buff-to-uint-be vrf))\\n    )\\n    (ok rand-uint)\\n  )\\n)\\n```\\n\\n### Converting strings to integers (and back)\\n\\nNow there are native functions for converting strings to integers and integers to strings.\\n\\n- `int-to-ascii`\\n- `int-to-utf8`\\n- `string-to-uint`\\n- `string-to-int`\\n\\nFor integer conversion, the same function works with both `uint` and `int`. Same for string conversion - you can use `string-ascii` and `string-utf8`.\\n\\nWhen converting a string to an integer, the result is `(optional uint)`. If you pass a number that can\'t be converted, the result is `none`.\\n\\n```clarity\\n(int-to-ascii u32) ;; \\"32\\"\\n(string-to-uint \\"32\\");; (some u32)\\n(string-to-uint \\"not-number\\") ;; none\\n```\\n\\nOne example where this could be useful is when you need to add index numbers to strings in a list. Here\'s a function that does that:\\n\\n```clarity\\n(define-read-only (indexed-list (items (list 10 (string-ascii 32))))\\n  (let\\n    (\\n      (iterator { index: u1, names: (list) })\\n      (fold-result (try! (fold indexed-list-fold items (ok iterator))))\\n      (names (get names fold-result))\\n    )\\n    (ok names)\\n  )\\n)\\n\\n(define-read-only (indexed-list-fold\\n    (item (string-ascii 32))\\n    (iterator-resp (response { index: uint, names: (list 10 (string-ascii 35)) } uint))\\n  )\\n  (let\\n    (\\n      (iterator (try! iterator-resp))\\n      (names (unwrap! (as-max-len? (get names iterator) u9) (err u0)))\\n      (index (get index iterator))\\n      (name-a (concat (int-to-ascii index) \\". \\"))\\n      (name-full (concat name-a item))\\n      ;; because our list size is only 10, we know this string can\'t be more than\\n      ;; 35 characters. By default, the string type would be (string-ascii 74), to\\n      ;; account for the largest possible integer.\\n      (name (unwrap! (as-max-len? name-full u35) (err u1)))\\n      (new-names (append names name))\\n    )\\n    (ok { index: (+ index u1), names: new-names })\\n  )\\n)\\n\\n(try! (indexed-list (list \\"alice\\" \\"bob\\"))) ;; (list \\"1. alice\\" \\"2. bob\\")\\n```\\n\\n### Slice\\n\\n`slice` is a very helpful utility when dealing with hashes, buffers, and strings. This function works like `slice` in most languages - it selects the elements between `beginning` and `end` indexes that you specify. This is a crucial utility when parsing a Bitcoin block header, for example.\\n\\nPreviously, you could only use `as-max-len?` if you wanted to take two long strings and concatenate them into a shorter string. For example, imagine you have two tokens A and B. Their on-chain `name` returns a 16-character string, but you want to create a pool whose name is auto-generated with their two names. If you tried that with `as-max-len?`, you\'d get a `none` result if either of the names was too long. With `slice`, you can cut off their names if they go too long.\\n\\nThis becomes extra handy when you\'re trying to conform to traits that limit the length of a result.\\n\\n**Note about slice**: At the moment, I saw some unintuitive behavior around the length of the result of `slice`. The length of the result of `slice` did not actually shorten to what I was expecting. I had to use `as-max-len?` to do type-safe operations. I\'ll keep this updated if there are any changes.\\n\\n```clarity\\n;; Take two strings and return \\"${a} ${b} Pool\\", with a length no longer than 32 characters.\\n(define-read-only (make-pool-name (name-a (string-ascii 32)) (name-b (string-ascii 32)))\\n  (let\\n    (\\n      (a-short (slice name-a u0 u13))\\n      (b-short (slice name-b u0 u13))\\n      (a (concat a-short \\" \\"))\\n      (b (concat b-short \\" Pool\\"))\\n    )\\n    (concat a b)\\n  )\\n)\\n```\\n\\n### Comparators for strings and buffs\\n\\nClarity already has `>`, `>=`, `<`, and `<=` for integers. In 2.1, you can also use this with strings and buffers.\\n\\n```clarity\\n(define-read-only (test-string-comparisons)\\n  (begin\\n    (asserts! (> \\"bbb\\" \\"aaa\\") (err u0))\\n    (asserts! (>= u\\"bbb\\" u\\"bbb\\") (err u1))\\n    (asserts! (< 0x01 0x02) (err u2))\\n    (ok true)\\n  )\\n)\\n```\\n\\n### STX account information\\n\\nYou can currently use `stx-get-balance`, but in 2.1 you can get information about the locked balance (through Stacking) for a given principal. This function returns a tuple with `locked`, `unlock-height`, and `unlocked`.\\n\\n```clarity\\n(stx-account \'ST000000000000000000002AMW42H)\\n;; { locked: u0, unlock-height: u0, unlocked: u0 }\\n```\\n\\nHere is a simple function that returns `true` if the user is currently stacking:\\n\\n```clarity\\n(define-read-only (is-stacking (account principal))\\n  (if (> (get locked (stx-account account)) u0)\\n    true\\n    false\\n  )\\n)\\n```\\n\\n### STX transfer with memo\\n\\nStacks is an account-based protocol, so exchanges typically rely on users having a unique \\"memo\\" to associate transfers into their exchange account. This works well for vanilla STX transfers (which support memos), but exchanges won\'t recognize STX transfers from within contract calls.\\n\\nIn fact, exchanges ran into an issue when users tried to withdraw from one exchange to another. Instead of making dozens of individual transactions, exchanges would prefer to use a \\"bulk send\\" contract call. This works well, except that you can\'t natively include a memo. The ecosystem ended up developing a special `send-many-memo` contract that would `print` memos, and exchanges could use an API to recognize these transfers.\\n\\nUsing a special contract is messy, though. The new `stx-transfer-memo?` function will simplify all this.\\n\\n```clarity\\n(stx-transfer-memo? u1234 tx-sender \'ST000000000000000000002AMW42H 0x010203)\\n```\\n\\n### `is-standard`\\n\\nThe `is-standard` function simply checks to see if a given `principal` is in the correct format for the current network. This allows for additional safety - if a user sends tokens to a principal that could never spend them (on this network), that would be a bad outcome.\\n\\n```clarity\\n(is-standard \'STB44HYPYAT2BB2QE513NSP81HTMYWBJP02HPGK6) ;; returns true on testnet and false on mainnet\\n(is-standard \'STB44HYPYAT2BB2QE513NSP81HTMYWBJP02HPGK6.foo) ;; returns true on testnet and false on mainnet\\n(is-standard \'SP3X6QWWETNBZWGBK6DRGTR1KX50S74D3433WDGJY) ;; returns true on mainnet and false on testnet\\n(is-standard \'SP3X6QWWETNBZWGBK6DRGTR1KX50S74D3433WDGJY.foo) ;; returns true on mainnet and false on testnet\\n(is-standard \'SZ2J6ZY48GV1EZ5V2V5RB9MP66SW86PYKKQ9H6DPR) ;; returns false on both mainnet and testnet\\n```\\n\\n### `principal-of`\\n\\n`principal-of` converts a public key to a standard STX address. This was already built in Stacks 2.0, but it shipped with a bug on mainnet. On mainnet, the result would return a testnet-formatted address. Unfortunately, that made this function mostly useless. The fix had to wait until 2.1 because fixing it would technically be consensus-breaking, so it needed to be in a hard fork.\\n\\nI\'ve found that there are a ton of interesting use cases for `principal-of`. It allows for all sorts of off-chain signatures to execute address-specific logic in a contract.\\n\\nFor example, imagine a voting contract. The contract keeps track of what individual users vote on. This could get expensive with lots of voters. Instead, signatures could be generated offline and then submitted on-chain in a single batch transaction.\\n\\n```clarity\\n(define-map votes-map principal uint)\\n\\n;; submit a list of votes, with signatures generated off-chain\\n(define-public (batch-votes (votes (list 20 { signature: (buff 65), proposal: uint })))\\n  (ok (map process-vote votes))\\n)\\n\\n(define-public (process-vote (vote { signature: (buff 65), proposal: uint }))\\n  (let\\n    (\\n      (proposal (get proposal vote))\\n      (message-hash (sha256 proposal))\\n      (public-key (unwrap! (secp256k1-recover? message-hash (get signature vote)) (err u0)))\\n      (voter (unwrap! (principal-of? public-key) (err u1)))\\n    )\\n    (map-set votes-map voter proposal)\\n    (ok true)\\n  )\\n)\\n```"}]}')}}]);